
/*
 * Automatically generated by asn1_compiler.  Do not edit
 *
 * ASN.1 parser for x509_san
 */
#include "asn1_ber_bytecode.h"
#include "x509_san_asn1.h"

// clang-format off

enum x509_san_actions {
	ACT_x509_extract_name_segment = 0,
	ACT_x509_san_OID = 1,
	ACT_x509_san_dns = 2,
	ACT_x509_san_ip = 3,
	NR__x509_san_actions = 4
};

static const asn1_action_t x509_san_action_table[NR__x509_san_actions] = {
	[   0] = x509_extract_name_segment,
	[   1] = x509_san_OID,
	[   2] = x509_san_dns,
	[   3] = x509_san_ip,
};

static const asn1_action_enc_t x509_san_action_table_enc[NR__x509_san_actions] = {
	[   0] = x509_extract_name_segment_enc,
	[   1] = x509_san_OID_enc,
	[   2] = x509_san_dns_enc,
	[   3] = x509_san_ip_enc,
};

static const unsigned char x509_san_machine[] = {
	// SubjectAltName
	// GeneralNames
	[   0] = ASN1_OP_MATCH,
	[   1] = _tag(UNIV, CONS, SEQ),
	// GeneralName
	// OtherName
	[   2] =  ASN1_OP_MATCH_JUMP_OR_SKIP,		// otherName
	[   3] =  _tagn(CONT, CONS,  0),
	[   4] =  _jump_target(30),		// --> OtherName
	[   5] =  ASN1_OP_COND_MATCH_OR_SKIP,		// rfc822Name
	[   6] =  _tagn(CONT, PRIM,  1),
	[   7] =  ASN1_OP_COND_MATCH_ACT_OR_SKIP,		// dNSName
	[   8] =  _tagn(CONT, PRIM,  2),
	[   9] =  _action(ACT_x509_san_dns),
	[  10] =  ASN1_OP_COND_MATCH_JUMP_OR_SKIP,		// x400Address
	[  11] =  _tagn(CONT, CONS,  3),
	[  12] =  _jump_target(38),
	[  13] =  ASN1_OP_COND_MATCH_JUMP_OR_SKIP,		// directoryName
	[  14] =  _tagn(CONT, CONS,  4),
	[  15] =  _jump_target(41),
	// EDIPartyName
	[  16] =  ASN1_OP_COND_MATCH_JUMP_OR_SKIP,		// ediPartyName
	[  17] =  _tagn(CONT, CONS,  5),
	[  18] =  _jump_target(59),		// --> EDIPartyName
	[  19] =  ASN1_OP_COND_MATCH_OR_SKIP,		// uniformResourceIdentifier
	[  20] =  _tagn(CONT, PRIM,  6),
	[  21] =  ASN1_OP_COND_MATCH_ACT_OR_SKIP,		// iPAddress
	[  22] =  _tagn(CONT, PRIM,  7),
	[  23] =  _action(ACT_x509_san_ip),
	[  24] =  ASN1_OP_COND_MATCH_OR_SKIP,		// registeredID
	[  25] =  _tagn(CONT, PRIM,  8),
	[  26] =  ASN1_OP_COND_FAIL,
	[  27] = ASN1_OP_END_SEQ_OF,
	[  28] = _jump_target(2),
	[  29] = ASN1_OP_COMPLETE,

	[  30] =  ASN1_OP_MATCH,		// type-id
	[  31] =  _tag(UNIV, PRIM, OID),
	[  32] =  ASN1_OP_MATCH,		// value
	[  33] =  _tagn(CONT, CONS,  0),
	[  34] =   ASN1_OP_MATCH_ANY,		// value
	[  35] =  ASN1_OP_END_SEQ,
	[  36] = ASN1_OP_END_SEQ,
	[  37] = ASN1_OP_RETURN,

	[  38] =  ASN1_OP_MATCH_ANY,		// x400Address
	[  39] = ASN1_OP_END_SEQ,
	[  40] = ASN1_OP_RETURN,

	// Name
	[  41] =  ASN1_OP_MATCH,
	[  42] =  _tag(UNIV, CONS, SEQ),
	// RelativeDistinguishedName
	[  43] =   ASN1_OP_MATCH,
	[  44] =   _tag(UNIV, CONS, SET),
	// AttributeValueAssertion
	[  45] =    ASN1_OP_MATCH,
	[  46] =    _tag(UNIV, CONS, SEQ),
	[  47] =     ASN1_OP_MATCH_ACT,		// attributeType
	[  48] =     _tag(UNIV, PRIM, OID),
	[  49] =     _action(ACT_x509_san_OID),
	[  50] =     ASN1_OP_MATCH_ANY_ACT,		// attributeValue
	[  51] =     _action(ACT_x509_extract_name_segment),
	[  52] =    ASN1_OP_END_SEQ,
	[  53] =   ASN1_OP_END_SET_OF,
	[  54] =   _jump_target(45),
	[  55] =  ASN1_OP_END_SEQ_OF,
	[  56] =  _jump_target(43),
	[  57] = ASN1_OP_END_SEQ,
	[  58] = ASN1_OP_RETURN,

	[  59] =  ASN1_OP_MATCH_JUMP_OR_SKIP,		// nameAssigner
	[  60] =  _tagn(CONT, CONS,  0),
	[  61] =  _jump_target(68),
	[  62] =  ASN1_OP_MATCH,		// partyName
	[  63] =  _tagn(CONT, CONS,  1),
	[  64] =   ASN1_OP_MATCH_ANY,		// partyName
	[  65] =  ASN1_OP_END_SEQ,
	[  66] = ASN1_OP_END_SEQ,
	[  67] = ASN1_OP_RETURN,

	[  68] =  ASN1_OP_MATCH_ANY,		// nameAssigner
	[  69] = ASN1_OP_END_SEQ,
	[  70] = ASN1_OP_RETURN,
};

const struct asn1_decoder x509_san_decoder = {
	.machine = x509_san_machine,
	.machlen = sizeof(x509_san_machine),
	.actions = x509_san_action_table,
};

const struct asn1_encoder x509_san_encoder = {
	.machine = x509_san_machine,
	.machlen = sizeof(x509_san_machine),
	.actions = x509_san_action_table_enc,
};

// clang-format on
